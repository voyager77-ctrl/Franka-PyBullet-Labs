## Core Concepts
1. Cartesian Impedance Physics

The controller simulates a physical spring-damper connected to the robot's end-effector. The desired dynamic behavior is governed by:
Ftask​=−(Ke+De˙)

Where:

    K (Stiffness): Defined as stiffness_diag = [150, 150, 150, 10, 10, 10]. It pulls the robot back to the equilibrium point.

    D (Damping): Set to be critically damped (D=2K​) to ensure the robot returns to position without oscillating or overshooting.

2. The Jacobian (J) & Torque Mapping

Since we want to control the robot in Task Space (Cartesian coordinates) but motors operate in Joint Space (Torques), we use the Jacobian matrix to bridge the two.

    Velocity Mapping: x˙=J(q)q˙​

    Force-Torque Duality: τtask​=J(q)TFtask​

By transposing the Jacobian, we translate the desired 3D force at the hand into the specific motor torques required across the 7-DOF arm.

3. Dynamics Compensation

To ensure the robot doesn't collapse under its own weight, the controller calculates and adds compensation terms:

    Gravity (τg​): Counteracts the weight of the robot links.

    Coriolis (τC​): Compensates for forces generated by the robot's own movement.

The final control law applied is:
τtotal​=τtask​+τg​+τC​

## Engineering & Safety Features

    1kHz Control Loop: The simulation runs at 1000Hz (dt=0.001) to maintain numerical stability of the virtual spring.

    Torque Rate Limiting: Torques are clipped to a maximum change of 1000Nm/s, mimicking the hardware safety limits of the real Franka Emika Panda.

    Orientation Error: Uses a small-angle approximation via rotation matrices to compute the shortest path rotation error between the current and desired end-effector pose.


## Getting Started
Prerequisites
Bash

pip install pybullet numpy

Running the Simulation
Bash

python franka_impedance_control.py

Interaction: Use Ctrl + Mouse Click to drag the robot arm. You will feel the "compliance" as the robot resists your pull like a heavy spring and returns to its original pose once released.
